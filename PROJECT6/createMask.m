function [BW,maskedRGBImage] = createMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 27-May-2020
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.000;
channel1Max = 1.000;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.000;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.000;
channel3Max = 1.000;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);

% Create mask based on selected regions of interest on point cloud projection
I = double(I);
[m,n,~] = size(I);
polyBW = false([m,n]);
I = reshape(I,[m*n 3]);

% Convert HSV color space to canonical coordinates
Xcoord = I(:,2).*I(:,3).*cos(2*pi*I(:,1));
Ycoord = I(:,2).*I(:,3).*sin(2*pi*I(:,1));
I(:,1) = Xcoord;
I(:,2) = Ycoord;
clear Xcoord Ycoord

% Project 3D data into 2D projected view from current camera view point within app
J_white = rotateColorSpace_white(I);
J_darkblue = rotateColorSpace_darkblue(I);
J_lightblue = rotateColorSpace_lightblue(I);
J_pink = rotateColorSpace_pink(I);
J_green = rotateColorSpace_green(I);
J_red = rotateColorSpace_red(I);
J_yellow = rotateColorSpace_yellow(I);

% Apply polygons drawn on point cloud in app
polyBW_white = applyPolygons_white(J_white,polyBW);
polyBW_darkblue = applyPolygons_darkblue(J_darkblue,polyBW);
polyBW_lightblue = applyPolygons_lightblue(J_lightblue,polyBW);
polyBW_pink = applyPolygons_pink(J_pink,polyBW);
polyBW_green = applyPolygons_green(J_green,polyBW);
polyBW_red = applyPolygons_red(J_red,polyBW);
polyBW_yellow = applyPolygons_yellow(J_yellow,polyBW);

% Combine all masks
BW_white = sliderBW & polyBW_white;
BW_darkblue= sliderBW & polyBW_darkblue;
BW_lightblue= sliderBW & polyBW_lightblue;
BW_pink = sliderBW & polyBW_pink;
BW_green = sliderBW & polyBW_green;
BW_red = sliderBW & polyBW_red;
BW_yellow = sliderBW & polyBW_yellow;

BW=BW_white+BW_darkblue+BW_lightblue+BW_pink+BW_green+BW_red+BW_yellow;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end

function J = rotateColorSpace_white(I)

% Translate the data to the mean of the current image within app
shiftVec = [0.089229 0.041782 0.455921];
I = I - shiftVec;
I = [I ones(size(I,1),1)]';

% Apply transformation matrix
tMat = [0.517442 -0.077279 -0.000000 -0.453568;
    0.018546 0.347667 0.841635 -0.675752;
    0.042298 0.792918 -0.369028 8.364221;
    0.000000 0.000000 0.000000 1.000000];

J = (tMat*I)';
end

function polyBW = applyPolygons_white(J,polyBW)

% Define each manually generated ROI
hPoints(1).data = [-0.572370 -0.228987;
    -0.556646 -0.440360;
    -0.511222 -0.472386;
    -0.469292 -0.405131;
    -0.464050 -0.200163;
    -0.556646 -0.104085];

% Iteratively apply each ROI
for ii = 1:length(hPoints)
    if size(hPoints(ii).data,1) > 2
        in = inpolygon(J(:,1),J(:,2),hPoints(ii).data(:,1),hPoints(ii).data(:,2));
        in = reshape(in,size(polyBW));
        polyBW = polyBW | in;
    end
end

end

function J = rotateColorSpace_lightblue(I)

% Translate the data to the mean of the current image within app
shiftVec = [0.089229 0.041782 0.455921];
I = I - shiftVec;
I = [I ones(size(I,1),1)]';

% Apply transformation matrix
tMat = [-0.519165 0.031165 0.000000 0.481752;
    -0.003241 -0.151150 0.904965 -0.402309;
    -0.018342 -0.855422 -0.159904 9.256964;
    0.000000 0.000000 0.000000 1.000000];

J = (tMat*I)';
end

function polyBW = applyPolygons_lightblue(J,polyBW)

% Define each manually generated ROI
hPoints(1).data = [0.576771 0.123540;
    0.593441 -0.356763;
    0.693462 -0.221505;
    0.716800 0.140102];

% Iteratively apply each ROI
for ii = 1:length(hPoints)
    if size(hPoints(ii).data,1) > 2
        in = inpolygon(J(:,1),J(:,2),hPoints(ii).data(:,1),hPoints(ii).data(:,2));
        in = reshape(in,size(polyBW));
        polyBW = polyBW | in;
    end
end

end

function J = rotateColorSpace_pink(I)

% Translate the data to the mean of the current image within app
shiftVec = [0.089229 0.041782 0.455921];
I = I - shiftVec;
I = [I ones(size(I,1),1)]';

% Apply transformation matrix
tMat = [-0.496399 0.256320 0.000000 0.330327;
    -0.153190 -0.830581 0.000000 0.625207;
    0.000000 0.000000 -0.918984 9.160254;
    0.000000 0.000000 0.000000 1.000000];

J = (tMat*I)';
end

function polyBW = applyPolygons_pink(J,polyBW)

% Define each manually generated ROI
hPoints(1).data = [0.177297 0.813362;
    0.219581 0.671135;
    0.271934 0.703729;
    0.316232 0.801510;
    0.265893 0.902254];

% Iteratively apply each ROI
for ii = 1:length(hPoints)
    if size(hPoints(ii).data,1) > 2
        in = inpolygon(J(:,1),J(:,2),hPoints(ii).data(:,1),hPoints(ii).data(:,2));
        in = reshape(in,size(polyBW));
        polyBW = polyBW | in;
    end
end

end

function J = rotateColorSpace_green(I)

% Translate the data to the mean of the current image within app
shiftVec = [0.089229 0.041782 0.455921];
I = I - shiftVec;
I = [I ones(size(I,1),1)]';

% Apply transformation matrix
tMat = [-0.442390 0.455687 0.000000 0.163664;
    -0.272343 -0.740211 0.000000 0.687906;
    0.000000 0.000000 -0.918984 9.160254;
    0.000000 0.000000 0.000000 1.000000];

J = (tMat*I)';
end

function polyBW = applyPolygons_green(J,polyBW)

% Define each manually generated ROI
hPoints(1).data = [0.214620 0.676495;
    0.400720 0.656933;
    0.595682 0.673235;
    0.584605 0.813424;
    0.482693 0.868848;
    0.416229 0.849286;
    0.327609 0.813424;
    0.258930 0.780822];

% Iteratively apply each ROI
for ii = 1:length(hPoints)
    if size(hPoints(ii).data,1) > 2
        in = inpolygon(J(:,1),J(:,2),hPoints(ii).data(:,1),hPoints(ii).data(:,2));
        in = reshape(in,size(polyBW));
        polyBW = polyBW | in;
    end
end

end

function J = rotateColorSpace_red(I)

% Translate the data to the mean of the current image within app
shiftVec = [0.089229 0.041782 0.455921];
I = I - shiftVec;
I = [I ones(size(I,1),1)]';

% Apply transformation matrix
tMat = [0.226929 0.781915 0.000000 -0.668185;
    -0.467314 0.379701 0.000000 0.231362;
    0.000000 0.000000 -0.918984 9.160254;
    0.000000 0.000000 0.000000 1.000000];

J = (tMat*I)';
end

function polyBW = applyPolygons_red(J,polyBW)

% Define each manually generated ROI
hPoints(1).data = [-0.711225 0.087275;
    -0.496028 0.074608;
    -0.418557 -0.134398;
    -0.702617 -0.299069];

% Iteratively apply each ROI
for ii = 1:length(hPoints)
    if size(hPoints(ii).data,1) > 2
        in = inpolygon(J(:,1),J(:,2),hPoints(ii).data(:,1),hPoints(ii).data(:,2));
        in = reshape(in,size(polyBW));
        polyBW = polyBW | in;
    end
end

end

function J = rotateColorSpace_yellow(I)

% Translate the data to the mean of the current image within app
shiftVec = [0.089229 0.041782 0.455921];
I = I - shiftVec;
I = [I ones(size(I,1),1)]';

% Apply transformation matrix
tMat = [0.258844 0.753649 0.000000 -0.682643;
    -0.450421 0.433101 0.000000 0.184386;
    0.000000 0.000000 -0.918984 9.160254;
    0.000000 0.000000 0.000000 1.000000];

J = (tMat*I)';
end

function polyBW = applyPolygons_yellow(J,polyBW)

% Define each manually generated ROI
hPoints(1).data = [-0.432011 0.305709;
    -0.394636 -0.088995;
    -0.117621 -0.008113;
    -0.069254 0.386591];

% Iteratively apply each ROI
for ii = 1:length(hPoints)
    if size(hPoints(ii).data,1) > 2
        in = inpolygon(J(:,1),J(:,2),hPoints(ii).data(:,1),hPoints(ii).data(:,2));
        in = reshape(in,size(polyBW));
        polyBW = polyBW | in;
    end
end

end

function J = rotateColorSpace_darkblue(I)

% Translate the data to the mean of the current image within app
shiftVec = [0.252235 0.112331 0.594979];
I = I - shiftVec;
I = [I ones(size(I,1),1)]';

% Apply transformation matrix
tMat = [-0.199949 -0.859948 0.000000 0.642567;
    -0.084231 0.049730 0.835573 -0.447807;
    0.533048 -0.314713 0.132035 8.290691;
    0.000000 0.000000 0.000000 1.000000];

J = (tMat*I)';
end

function polyBW = applyPolygons_darkblue(J,polyBW)

% Define each manually generated ROI
hPoints(1).data = [0.822610 -0.716729;
    0.841235 -0.865975;
    0.932292 -0.888502;
    1.240641 -0.167620;
    1.110265 -0.021191;
    0.861930 -0.632251];

% Iteratively apply each ROI
for ii = 1:length(hPoints)
    if size(hPoints(ii).data,1) > 2
        in = inpolygon(J(:,1),J(:,2),hPoints(ii).data(:,1),hPoints(ii).data(:,2));
        in = reshape(in,size(polyBW));
        polyBW = polyBW | in;
    end
end

end
